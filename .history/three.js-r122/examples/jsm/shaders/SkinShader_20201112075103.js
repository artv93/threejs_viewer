/**
 * Simple test shader
 */

var BasicShader = {

	uniforms: {},

	vertexShader: [

		"void main() {",

		"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join( "\n" ),

	fragmentShader: "#define USE_TRANSLUCENCY\r\n\r\n#ifdef USE_TRANSLUCENCY\r\n  uniform sampler2D thicknessMap;\r\n  uniform float thicknessPower;\r\n  uniform float thicknessScale;\r\n  uniform float thicknessDistortion;\r\n  uniform float thicknessAmbient;\r\n  uniform vec2 thicknessRepeat;\r\n#endif\r\n\r\n#define PHYSICAL\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform float roughness;\r\nuniform float metalness;\r\nuniform float opacity;\r\n\r\n#ifndef STANDARD\r\n  uniform float clearCoat;\r\n  uniform float clearCoatRoughness;\r\n#endif\r\n\r\nuniform float envMapIntensity; \/\/ temporary\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n  varying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <bsdfs>\r\n#include <cube_uv_reflection_fragment>\r\n#include <lights_pars>\r\n#include <lights_physical_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <roughnessmap_pars_fragment>\r\n#include <metalnessmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n  #include <clipping_planes_fragment>\r\n\r\n  vec4 diffuseColor = vec4( diffuse, opacity );\r\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n  vec3 totalEmissiveRadiance = emissive;\r\n\r\n  #include <logdepthbuf_fragment>\r\n  #include <map_fragment>\r\n  #include <color_fragment>\r\n  #include <alphamap_fragment>\r\n  #include <alphatest_fragment>\r\n  #include <specularmap_fragment>\r\n  #include <roughnessmap_fragment>\r\n  #include <metalnessmap_fragment>\r\n  #include <normal_flip>\r\n  #include <normal_fragment>\r\n  #include <emissivemap_fragment>\r\n\r\n  \/\/ accumulation\r\n  #include <lights_physical_fragment>\r\n  #include <lights_template>\r\n\r\n  #ifdef USE_TRANSLUCENCY\r\n    vec3 thicknessColor = vec3(1.0, 1.0, 1.0);\r\n    vec3 thickness = thicknessColor * texture2D(thicknessMap, vUv * thicknessRepeat).r;\r\n    vec3 N = geometry.normal;\r\n    vec3 V = normalize(geometry.viewDir);\r\n    float thicknessCutoff = 0.75;\r\n    float thicknessDecay = 1.0;\r\n    \r\n    #if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\r\n\r\n      for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n\r\n        pointLight = pointLights[ i ];\r\n\r\n        vec3 vLightDir = pointLight.position - geometry.position;\r\n        vec3 L = normalize(vLightDir);\r\n\r\n        float lightDist = length(vLightDir);\r\n        float lightAtten = punctualLightIntensityToIrradianceFactor(lightDist, pointLight.distance, pointLight.decay);\r\n        \r\n        vec3 LTLight = normalize(L + (N * thicknessDistortion));\r\n        float LTDot = pow(saturate(dot(V, -LTLight)), thicknessPower) * thicknessScale;\r\n        vec3 LT = lightAtten * (LTDot + thicknessAmbient) * thickness;\r\n        reflectedLight.directDiffuse += material.diffuseColor * pointLight.color * LT;\r\n\r\n      }\r\n\r\n    #endif\r\n\r\n    #if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\r\n      \r\n\r\n      for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\r\n\r\n        rectAreaLight = rectAreaLights[ i ];\r\n        \r\n        vec3 vLightDir = rectAreaLight.position - geometry.position;\r\n        vec3 L = normalize(vLightDir);\r\n\r\n        float lightDist = length(vLightDir);\r\n        float lightAtten = punctualLightIntensityToIrradianceFactor(lightDist, thicknessCutoff, thicknessDecay);\r\n        \r\n        vec3 LTLight = normalize(L + (N * thicknessDistortion));\r\n        float LTDot = pow(saturate(dot(V, -LTLight)), thicknessPower) * thicknessScale;\r\n        vec3 LT = lightAtten * (LTDot + thicknessAmbient) * thickness;\r\n        reflectedLight.directDiffuse += material.diffuseColor * rectAreaLight.color * LT;\r\n      }\r\n    #endif\r\n  #endif\r\n\r\n  \/\/ modulation\r\n  #include <aomap_fragment>\r\n\r\n  vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n\r\n  gl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n  #include <premultiplied_alpha_fragment>\r\n  #include <tonemapping_fragment>\r\n  #include <encodings_fragment>\r\n  #include <fog_fragment>\r\n\r\n}";

};

export { BasicShader };
